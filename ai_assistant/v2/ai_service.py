import logging
from typing import List

from langchain.load.dump import dumps
from langchain_core.messages import AIMessage, BaseMessage, HumanMessage

from ai_assistant.models import Message
from ai_assistant.v2.agent import agent_executor

logger = logging.getLogger(__name__)


class AiService:
    def __init__(self):
        self.agent = agent_executor

    def run(self, query: str, user) -> str:
        """
        Run the AI agent with the provided query and return the response.
        Includes message history from the last 10 messages.

        :param query: The user's query to be processed by the AI agent.
        :param user: The user object to fetch message history for.
        :return: The response generated by the AI agent.
        """

        # Get message history for context
        message_history = self._get_message_history(user)

        # Create current user message
        current_message = HumanMessage(content=query)

        # Combine history with current message
        all_messages = message_history + [current_message]

        # Store the inbound message
        self._store_message(query, Message.Direction.INBOUND, user)

        # Get AI response
        response = self.agent.invoke({"messages": all_messages})
        self._log_response(response)
        ai_response = self._extract_response(response)

        self._store_message(ai_response, Message.Direction.OUTBOUND, user)

        return ai_response

    def _log_response(self, response):
        """
        Log the response from the AI agent in a structured format.

        :param response: The response dictionary returned by the agent.
        """
        logger.info("AI Response: %s", dumps(response, indent=2, ensure_ascii=False))

    def _get_message_history(self, user) -> List[BaseMessage]:
        """
        Fetch the latest 10 messages for the user and convert them to LangChain message format.

        :param user: The user object to fetch messages for.
        :return: List of LangChain message objects.
        """
        messages = Message.objects.filter(user=user).order_by("-created_at")[:10]

        # Reverse to get chronological order (oldest first)
        messages = list(reversed(messages))

        langchain_messages = []
        for message in messages:
            if message.direction == Message.Direction.INBOUND:
                langchain_messages.append(HumanMessage(content=message.message))
            else:  # OUTBOUND
                langchain_messages.append(AIMessage(content=message.message))

        return langchain_messages

    def _store_message(
        self, content: str, direction: Message.Direction, user
    ) -> Message:
        """
        Store a message in the database.

        :param content: The message content.
        :param direction: The message direction (inbound/outbound).
        :param user: The user object.
        :return: The created Message object.
        """
        message = Message.objects.create(
            message=content, direction=direction, user=user
        )
        return message

    def _parse_query(self, query: str) -> HumanMessage:
        """
        Parse the query into a HumanMessage format.

        :param query: The user's query.
        :return: A HumanMessage object containing the query.
        """
        return HumanMessage(content=query)

    def _get_message_list(self, query: str) -> list[HumanMessage]:
        """
        Convert the query into a list of HumanMessage objects.

        :param query: The user's query.
        :return: A list containing a single HumanMessage object with the query.
        """
        return [self._parse_query(query)]

    def _extract_response(self, response: dict) -> str:
        """
        Extract the AI response from the agent's response dictionary.

        :param response: The response dictionary returned by the agent.
        :return: The AI's response as a string.
        """
        # message = response["messages"][-1].content
        message = response["messages"][-1].content[0]["text"]
        return message
